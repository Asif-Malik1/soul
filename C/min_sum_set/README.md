** 题目：假设有两个集合A，B，调整他们，使之和的差最小。例如A={5，5，5，5，5}，B={3，3，1，1，1}，调整之后是{5，5，5，1，1}和{5，5，3，3，1}

** 思路
1. 假设当前两集合是由大到小排好序的，且已满足条件，考虑如何插入一个新元素。
2. 合并集合A、B，得到C并对C排序。
3. 将C中元素从大到小依次插入到A和B

** 伪代码
    struct simarr {
        int sp; // 下一个空闲位置（当前长度）
        int val[100]; // 保存元素的数组
    };
    A、B、C类型均为simarr

    merge(A, B, C);
    qsort(0, C.sp - 1, C.val);

    0 -> d; // 当前两集合和之差
    while (C.sp > 0) {
        if (d > 0) {
            d - C.val[C.sp - 1] -> d;
            transfer(C, B); // 将C中最后一个元素插入B末尾
        }
        else {
            d + C.val[C.sp - 1] -> d;
            transfer(C, A); // 将C中最后一个元素插入A末尾
        }
    }

** 复杂度
    假设A有M个元素，B有N个原色，则
    时间：merge操作为O(M+N)，快排为O((M+N)lg(M+N))，后面插入操作为O(M+N)，因此总的时间复杂度为O((M+N)lg(M+N));
    空间：构造动态存储的数组，则只有标示当前数组长度的sp使用了额外空间，因此为O(1)

** 后续
1. 构造动态存储的数组；
2. 考虑大量元素；
